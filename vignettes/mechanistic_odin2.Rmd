---
title: "Mechanistic modelling in odin2 (scaffold)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Mechanistic modelling in odin2 (scaffold)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")

# This vignette is CI-safe by default. To actually *run* the code chunks, opt in:
#
#   Sys.setenv(VPDSUS_BUILD_ODIN2_VIGNETTE = "1")
#
.has_odin2 <- requireNamespace("odin2", quietly = TRUE)
.run_odin2 <- identical(Sys.getenv("VPDSUS_BUILD_ODIN2_VIGNETTE"), "1")
knitr::opts_chunk$set(eval = .has_odin2 && .run_odin2)
```

This vignette is optional.

- If `{odin2}` is not installed, chunks are shown but not executed.
- If `VPDSUS_BUILD_ODIN2_VIGNETTE != "1"` (the default), chunks are shown but not executed.

When enabled, this vignette requires the suggested packages `{odin2}` (and its dependency stack, e.g. `{dust2}`).

```{r}
library(vpdsus)

# Minimal discrete-time example (difference equation)
mdl <- odin2_build_model("minimal_discrete")
out <- odin2_simulate(
  mdl,
  times = 0:10,
  pars = list(inc = 1),
  initial = list(S = 0)
)

out

# Next step: a simple discrete-time susceptible balance model
mdl2 <- odin2_build_model("balance_discrete")
out2 <- odin2_simulate(
  mdl2,
  times = 0:5,
  pars = list(rho = 1, births = 0, vaccinated = 0, cases = 1),
  initial = list(S = 3)
)

out2

# Time-varying inputs (aligned to `times`)
times <- 0:4
out3 <- odin2_simulate(
  mdl2,
  times = times,
  pars = list(rho = 1),
  initial = list(S = 3),
  inputs = list(
    births = c(0, 1, 0, 0, 0),
    vaccinated = 0,
    cases = c(0, 0, 1, 0, 2)
  )
)

out3

# End-to-end example using the bundled example panel
panel_path <- system.file("extdata", "example_panel_small.csv", package = "vpdsus")
panel <- utils::read.csv(panel_path)

iso3 <- panel$iso3[[1]]
times <- sort(unique(panel$year))
inputs <- odin2_balance_inputs_from_panel(panel, times = times, iso3 = iso3)

out4 <- odin2_simulate(
  mdl2,
  times = times,
  pars = list(rho = 1),
  initial = list(S = 0),
  inputs = inputs
)

out4

# Compare to Method D (susceptible balance updated using cases)
#
# The `balance_discrete` template is intended to match the Method D recurrence,
# expressed as an explicit difference equation. Here we compute Method D and
# compare trajectories.

sus_d <- estimate_susceptible_case_balance(
  panel,
  rho = 1,
  s0 = 0,
  coverage_col = "coverage",
  births_col = "births",
  cases_col = "cases",
  pop_col = "pop_total",
  age_group = "total"
)

cmp <- dplyr::left_join(
  dplyr::mutate(out4, year = time),
  dplyr::select(sus_d, year, susceptible_n),
  by = "year"
)

cmp

# Simple comparison plot
p <- ggplot2::ggplot(
  cmp,
  ggplot2::aes(x = year)
) +
  ggplot2::geom_line(ggplot2::aes(y = S, colour = "odin2"), linewidth = 1) +
  ggplot2::geom_point(ggplot2::aes(y = S, colour = "odin2"), size = 2) +
  ggplot2::geom_line(ggplot2::aes(y = susceptible_n, colour = "method_d"), linewidth = 1, linetype = 2) +
  ggplot2::geom_point(ggplot2::aes(y = susceptible_n, colour = "method_d"), size = 2, shape = 1) +
  ggplot2::scale_colour_manual(values = c(odin2 = "#1b9e77", method_d = "#d95f02")) +
  ggplot2::labs(
    x = "Year",
    y = "Susceptible (count)",
    colour = NULL,
    title = paste0("Susceptible balance: odin2 vs Method D (", iso3, ")")
  ) +
  ggplot2::theme_minimal(base_size = 11)

p

# Optional: calibrate rho (reporting fraction) to a target susceptibility
#
# This is a minimal "inference hook" example. Here we create a target
# susceptible count and solve for rho such that the case-balance recurrence
# matches that target in a chosen year.

target_year <- max(times)
# For demonstration only: choose an arbitrary target susceptible count.
# In practice this could come from a cohort method estimate.
target_susceptible_n <- 1e6

rho_hat <- calibrate_rho_case_balance(
  panel,
  iso3 = iso3,
  years = times,
  target_year = target_year,
  target_susceptible_n = target_susceptible_n,
  rho_interval = c(0.01, 1)
)

rho_hat

out5 <- odin2_simulate(
  mdl2,
  times = times,
  pars = list(rho = rho_hat),
  initial = list(S = 0),
  inputs = inputs
)

out5
```

In a full implementation, you would map your panel data into model inputs.
